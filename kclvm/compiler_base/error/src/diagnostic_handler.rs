use crate::{
    diagnostic::diagnostic_message::TemplateLoader, Diagnostic, DiagnosticStyle, Emitter,
    MessageArgs,
};
use anyhow::Result;
use compiler_base_span::fatal_error::FatalError;
use std::sync::Arc;

pub(crate) struct DiagnosticHandlerInner {
    pub(crate) emitter: Box<dyn Emitter<DiagnosticStyle>>,
    pub(crate) diagnostics: Vec<Diagnostic<DiagnosticStyle>>,
    pub(crate) err_count: usize,
    pub(crate) warn_count: usize,
    pub(crate) template_loader: Arc<TemplateLoader>,
}

impl DiagnosticHandlerInner {
    // Add a diagnostic generated from error to `DiagnosticHandler`.
    // `DiagnosticHandler` contains a set of `Diagnostic<DiagnosticStyle>`
    pub(crate) fn add_err_diagnostic(&mut self, diag: Diagnostic<DiagnosticStyle>) {
        self.diagnostics.push(diag);
        self.err_count += 1;
    }

    // Add a diagnostic generated from warning to `DiagnosticHandler`.
    // `DiagnosticHandler` contains a set of `Diagnostic<DiagnosticStyle>`
    pub(crate) fn add_warn_diagnostic(&mut self, diag: Diagnostic<DiagnosticStyle>) {
        self.diagnostics.push(diag);
        self.warn_count += 1;
    }

    // Get count of diagnostics in `DiagnosticHandler`.
    // `DiagnosticHandler` contains a set of `Diagnostic<DiagnosticStyle>`
    pub(crate) fn diagnostics_count(&self) -> usize {
        self.diagnostics.len()
    }

    // Emit the diagnostic messages generated from error to to terminal stderr.
    pub(crate) fn emit_error_diagnostic(&mut self, diag: Diagnostic<DiagnosticStyle>) {
        self.emitter.emit_diagnostic(&diag);
        self.err_count += 1;
    }

    // Emit the diagnostic messages generated from warning to to terminal stderr.
    pub(crate) fn emit_warn_diagnostic(&mut self, diag: Diagnostic<DiagnosticStyle>) {
        self.emitter.emit_diagnostic(&diag);
        self.warn_count += 1;
    }

    // Emit all the diagnostics messages to to terminal stderr.
    // `DiagnosticHandler` contains a set of `Diagnostic<DiagnosticStyle>`
    pub(crate) fn emit_stashed_diagnostics(&mut self) {
        for diag in &self.diagnostics {
            self.emitter.emit_diagnostic(&diag)
        }
    }

    // If some diagnotsics generated by errors, `has_errors` returns `True`.
    pub(crate) fn has_errors(&self) -> bool {
        self.err_count > 0
    }

    // If some diagnotsics generated by warnings, `has_errors` returns `True`.
    pub(crate) fn has_warns(&self) -> bool {
        self.warn_count > 0
    }

    // After emitting all the diagnostics, it will panic.
    pub(crate) fn abort_if_errors(&mut self) {
        self.emit_stashed_diagnostics();

        if self.has_errors() {
            FatalError.raise();
        }
    }

    // Get the message string from "*.ftl" file by `index`, `sub_index` and `MessageArgs`.
    // "*.ftl" file looks like, e.g. './src/diagnostic/locales/en-US/default.ftl' :
    pub(crate) fn get_diagnostic_msg(
        &self,
        index: &str,
        sub_index: Option<&str>,
        args: &MessageArgs,
    ) -> Result<String> {
        self.template_loader.get_msg_to_str(index, sub_index, &args)
    }
}
